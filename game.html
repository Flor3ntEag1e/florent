<!DOCTYPE html>
<html ng-app>

<head>
     <title>-Light Speed Ready-</title>
	 	 <link rel="stylesheet" href="style/ScreenLayout.css" type="text/css" charset="utf-8">
     <script type="text/javascript" src="js/babylon.1.8.5.js"></script>

	 <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/angularjs/1.2.10/angular.min.js"></script>


</head>

<body>
	<div class="dir" id="dir">test</div>
	<div class="topLeft mainFont">Resources:<div id="Resources">0</div></div>
	<div class="topMiddle mainFont">Light Speed Gauge<div class="gauge"><div class="statusGaugeInside" id="lightspeedGauge"></div></div></div>
	<div class="bottomMiddle mainFont">Health<div class="largeGauge"><div class="statusGaugeInside" id="healthGauge"></div></div></div>
	<div id="boxes" class="bottomLeft">
	  <div class="box twitter"><img src="images/rocks.jpg" width="1024" height="1024" alt="Rocks">1</div>
	  <div class="box dribbble">2</div>
	  <div class="box pinterest">3</div>
	  <div class="box email">4</div>
	  <div class="box email">5</div>
	</div>
	
	<div ng-controller="levelingSystem" class="center mainFont statusScreen" id="nextLevelScreen">
		Upgrade Your Ship -Changing to Level 1-100<br/>Resources to Spend:{{Resources}}<br/> 
		Health<button ng-disabled="checkValid(5);" ng-click="UpgradeStat('Health', 1, 5);">+</button>{{maxHealth}}<button ng-click="UpgradeStat('Health', -1, -5);">-</button><br/>
		Damage<button ng-disabled="checkValid(10);"  ng-click="UpgradeStat('Damage', 1, 10);">+</button>{{bulletDamage}} <button ng-click="UpgradeStat('Damage', -1, -10);">-</button><br/>
		Ship Speed<button ng-disabled="checkValid(50);" ng-click="UpgradeStat('Speed', .1, 50);">+</button>{{speed}} <button ng-click="UpgradeStat('Speed', -.1, -50);">-</button><br/>
		Capacity<button ng-disabled="checkValid(1);" ng-click="UpgradeStat('Capacity', 1, 1);">+</button>{{ShipCapacity}} <button ng-click="UpgradeStat('Capacity', -1, -1);">-</button><br/>
		
		<button ng-click="save();">Save and go to next level</button></div>
	
	<div class="center mainFontLarge" id="deadScreen">You're DEAD<div class="mainFont"><button class="mainFont" onclick="Reset();">--New Game--</button></div></div>
	<div class="bottomRight mainFontLarge"><div id="level"></div></div>
          <canvas id="viewport"></canvas>
		  

</body>
<script src="js/enemies.js" type="text/javascript" ></script>
<script src="js/enemy.js" type="text/javascript" ></script>
<script src="js/levels.js" type="text/javascript" ></script>
       <script type="text/javascript">
var loaded = false;
	var level = 0, healthIncrease=5;
     var movex=0, movez=0, movey=0, particleSystem, enemies=[], playerGraphic,explosionSystem, camera, time,scene, light0, skybox, skyboxMaterial;
	 var player, playerStats, rock, cup, enemyexplosion,bulletobj,box, comet;
     var canvas = document.getElementById("viewport");
	 var lightSpeedGauge  = document.getElementById('lightspeedGauge');
	 var ResourcesText  = document.getElementById('Resources');
	 var HealthGauge  = document.getElementById('healthGauge');
	 var levelScreen  = document.getElementById('nextLevelScreen');
	 var LevelText  = document.getElementById('level');
	 var StatusText  = document.getElementById('dir');
	 var DeathScreen = document.getElementById('deadScreen');
	 var shootaudio = new Audio("assets/shoot2.wav");
	
	 var lightspeedaudio = new Audio("assets/lightspeed.wav");
	 lightspeedaudio.volume = .5;
	 var lightspeedstartaudio = new Audio("assets/lightspeedstart.wav");
	 lightspeedstartaudio.volume = .5;
	// var explodeaudio = new Audio("assets/explosion.wav");  
     var engine = new BABYLON.Engine(canvas,false)
      
	playerStats = new PlayerStats();
	
	function levelingSystem($scope) {
		$scope.maxHealth = playerStats.maxHealth;
		$scope.ShipCapacity = playerStats.ShipCapacity;
		$scope.speed = playerStats.speed;
		$scope.bulletDamage = playerStats.bulletDamage;
		$scope.Resources = playerStats.Resources;
	
		$scope.UpgradeStat = function (type, amount, cost)
		{
			if(type=="Health"){
				$scope.maxHealth += amount;
			}
			if(type=="Damage"){
				$scope.bulletDamage += amount;
			}
			if(type=="Speed"){
				$scope.speed += amount;
				$scope.speed = Math.round($scope.speed*100)/100;  
			}
			if(type=="Capacity"){
				$scope.ShipCapacity += amount;
			}
			$scope.Resources -= cost;
		}
		$scope.checkValid = function(total){
			if(total>$scope.Resources){return true;}
		}
		$scope.save = function()
		{
			playerStats.maxHealth = $scope.maxHealth;
			playerStats.ShipCapacity = $scope.ShipCapacity;
			playerStats.speed = $scope.speed;
			playerStats.bulletDamage = $scope.bulletDamage;
			playerStats.Resources = $scope.Resources;
			SceneReset();
		}
	}
	
	SceneSetup();

	function SceneSetup()
	{
		levelScreen.style.display = "none";
		if(engine != null)
		{
			engine.dispose()
		}
		if(scene != null)
		{
			scene.dispose();
		}
		LevelText.innerHTML = level;
		DeathScreen.style.display = "none";
		loaded = false;
		movex=0, movez=0, movey=0;
		enemies=[];
		time = 0;
	    engine = new BABYLON.Engine(canvas,false)
		   //engine.setHardwareScalingLevel(1);
		scene = new BABYLON.Scene(engine);
		scene.clearColor = new BABYLON.Color3(0,0,0);
        camera = new BABYLON.ArcRotateCamera("Camera", 0, 0, 500, new BABYLON.Vector3(0, 0, 0), scene);
  	    camera.maxZ = 20000;
	    bulletobj = BABYLON.Mesh.CreateSphere("bulletmain", 1,1, scene);
		bulletobj.isVisible =false;
	   	//box = BABYLON.Mesh.CreateBox("defaultBox", 10, scene);
	   
        BABYLON.SceneLoader.ImportMesh("", "", "Spaceship.babylon", scene, function (newMeshes, particleSystems) {
           newMeshes[0].scaling.x = .015;
           newMeshes[0].scaling.y = .015;
           newMeshes[0].scaling.z = .015;
           playerGraphic = newMeshes[0];
		   player = undefined;
   		   player = new Player();

   		   camera.target = player.BoundingBox.position;
   	  	   loaded = true;
     	});
		
        BABYLON.SceneLoader.ImportMesh("", "", "assets/a6.babylon", scene, function (newMeshes, particleSystems) {
        	rock =  newMeshes[0];
			rock.position.x = 850;
			rock.position.z = 850; 
			
   		 	var rockmaterial = new BABYLON.StandardMaterial("rockmaterial", scene);
   		 	rockmaterial.diffuseTexture = new BABYLON.Texture("images/marble.jpg", scene);
   		  	rockmaterial.bumpTexture = new BABYLON.Texture("images/Rocknormal.jpg", scene);
   		  	rockmaterial.specularColor = new BABYLON.Color3(0, 0, 0);		
     	    rockmaterial.diffuseTexture.uScale = .5;
     	    rockmaterial.diffuseTexture.vScale = .5;
   		   //rockmaterial.wireframe = true;
     		rock.material = rockmaterial;
			   BABYLON.SceneLoader.ImportMesh("", "", "assets/cup2.babylon", scene, function (newMeshes, particleSystems) {
           		cup =  newMeshes[0];
   				cup.position.x = 850;
   				cup.position.z = 850; 
	   	      
					SceneReset();
			   });
			
        });
		
		
	   light0 = new BABYLON.HemisphericLight("Omni", new BABYLON.Vector3(0, 0, -10), scene);
		
 	   skybox = BABYLON.Mesh.CreateBox("skyBox", 1500.0, scene);
 	   skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
 	   skyboxMaterial.backFaceCulling = false;
 	   skybox.material = skyboxMaterial;
 	   skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
 	   skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
 	   skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("skybox/skybox", scene);
 	   skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
	  // skybox.isVisible = false;
//scene.activeCamera.attachControl(canvas);


	}

	function SceneReset()
	{
		var lvlDetails = levels.filter(function(value){ return value.level==level; });
		if(lvlDetails.length!=0){
			var xEnemy = enemies.length;
			while(xEnemy--){
				enemies[xEnemy].dispose();
			}
			enemies = [];
			var typeAmount = lvlDetails[0].types.length;
			while(typeAmount--){
				var totalItems = lvlDetails[0].types[typeAmount].total;
				while(totalItems--){
					enemies.push(new BaseEnemy( enemiesDEF[ lvlDetails[0].types[typeAmount].type ] ));
				}
			}
		}
		/*
    	var enemyCount = 50;
    	while(enemyCount--) {
		 	enemies.push(new BaseEnemy( enemiesDEF[ 0 ], cup ));
    	}
    	 enemyCount = 50;
    	while(enemyCount--) {
		 	enemies.push(new BaseEnemy( enemiesDEF[ 1 ], rock ));
    	}
		enemies.push(new BaseEnemy( enemiesDEF[ 2 ], rock  ));
		*/
		LevelText.innerHTML = level;
		camera.radius = 500;
		ResourcesText.innerHTML =  playerStats.Resources + "/" + player.ShipCapacity;
		levelScreen.style.display = "none";
		player.LightSpeedGauge = 0;
		player.health = player.maxHealth;
		HealthGauge.style.width = ((player.health / player.maxHealth)*100) + "%"; 
		player.BoundingBox.position = new BABYLON.Vector3(0,0,0);
		player.Graphic.position = new BABYLON.Vector3(0,0,0);
	 	player.Graphic.rotation.x = 0; 
     	player.Graphic.rotation.y = 0;
		var totalEnemies = enemies.length;
		while(totalEnemies--){
			enemies[totalEnemies].respawn(level);
		}
		player.status = true;
	    camera.target = player.BoundingBox.position;
	}
	
	function Reset(){
		playerStats = new PlayerStats();
		scene.dispose();
		level =0;
		SceneSetup();
	}
 
	function PlayerStats(){
		this.Resources = 0;
		this.maxHealth = 100;
		this.ShipCapacity = 200;
		this.speed = 1;
		this.bulletSpeed = 2;
		this.bulletDamage = 25;
	}
	

	function Player(){
		this.playerStats = playerStats;
		this.LightSpeedGauge =0;
		this.Resources = 0;
		this.status = true;
		this.LightSpeedGaugeCapacity = 100;
		this.ShipCapacity = playerStats.ShipCapacity;
		this.health = playerStats.maxHealth;
		this.maxHealth = playerStats.maxHealth;
		this.shipSheildCap = 0;
		this.speed = playerStats.speed;
		this.bulletSpeed = playerStats.bulletSpeed;
		this.bulletDamage = playerStats.bulletDamage;
		var bulletsshot = 0;
		
		this.bullet = [];//  BABYLON.Mesh.CreateSphere("bullet", 2,2, scene);

		lightSpeedGauge.style.width = 0;
		ResourcesText.innerHTML =  this.playerStats.Resources + "/" + this.ShipCapacity;
		HealthGauge.style.width = "100%"; 
		
		
		this.BoundingBox = BABYLON.Mesh.CreateBox("Player", 13.0, scene);
   	  	var material = new BABYLON.StandardMaterial("texture1", scene);
        material.wireframe = true;
		this.BoundingBox.material = material;
		this.BoundingBox.isVisible = false;
		this.Graphic = playerGraphic;
		

          particleSystem = new BABYLON.ParticleSystem("particles", 100, scene);

         //Texture of each particle
         particleSystem.particleTexture = new BABYLON.Texture("images/Flare.png", scene);
		   // Where the particles comes from
      particleSystem.emitter = this.Graphic; // the starting object, the emitter
      particleSystem.minEmitBox = new BABYLON.Vector3(-100, 100, 700); // Starting all From
      particleSystem.maxEmitBox = new BABYLON.Vector3(100, 100, 800); // To...
    //  particleSystem.minEmitBox = new BABYLON.Vector3(-1, 1, 0); // Starting all From
    //  particleSystem.maxEmitBox = new BABYLON.Vector3(1, 1, 0); // To...

      // Colors of all particles (splited in 2 + specific color before dispose)
      particleSystem.color1 = new BABYLON.Color4(0.4, 0.8, 1.0, 1.0);
      particleSystem.color2 = new BABYLON.Color4(0.2, 0.5, 1.0, 1.0);
      particleSystem.colorDead = new BABYLON.Color4(0, 0, 0.2, 0.0);

      // Size of each particle (random between...
      particleSystem.minSize = 1.0;
      particleSystem.maxSize = 7.5;

      // Life time of each particle (random between...
      particleSystem.minLifeTime = 0.01;
      particleSystem.maxLifeTime = .25;

      // Emission rate
      particleSystem.emitRate = 1500;
      // OR
      //particleSystem.manualEmitCount = 1000;


      // Blend mode : BLENDMODE_ONEONE, or BLENDMODE_STANDARD
      particleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;

      //Set the gravity of all particles (not necessary down)
      particleSystem.gravity = new BABYLON.Vector3(0, -9.81, 0);

      //Direction of each particle after it has been emitted
      particleSystem.direction1 = new BABYLON.Vector3(-7, 8, 3);
      particleSystem.direction2 = new BABYLON.Vector3(7, 8, -3);

      //angular speed, in radian
      particleSystem.minAngularSpeed = 0;
      particleSystem.maxAngularSpeed = Math.PI;

      particleSystem.targetStopDuration = 0;

      //speed
      particleSystem.minEmitPower = 1;
      particleSystem.maxEmitPower = 3;
      particleSystem.updateSpeed = 0.005;

      //dispose
      particleSystem.disposeOnStop = true;

      //Start the particle system
      particleSystem.start();

	var totalBullets = 100;
      while(totalBullets--) {
		var newbullet = bulletobj.clone("bullet");
		newbullet.position.x = 15000;
		newbullet.position.z = 15000;
		newbullet.isVisible = false;
		bulletpart = particleSystem.clone("bulleting", newbullet);
        bulletpart.minEmitBox = new BABYLON.Vector3(0, 1, 0); // Starting all From
        bulletpart.maxEmitBox = new BABYLON.Vector3(0, 1, 0); // To...
        bulletpart.direction1 = new BABYLON.Vector3(-100, -100, -100);
        bulletpart.direction2 = new BABYLON.Vector3(100, 100, 100);
	    bulletpart.maxLifeTime = .1;
		bulletpart.maxSize = 5.5;
		//bulletpart.targetStopDuration = 2;
  	    this.bullet.push({'graphic': newbullet, 'direction':'right', 'damage': this.bulletDamage});
      }
	
	  
	this.explode = function(){
			if (this.Graphic._isEnabled == true){
			this.Graphic.isVisible = false;
			this.Graphic._isEnabled = false;
			
            explosionSystem = new BABYLON.ParticleSystem("particlesexplode", 2000, scene);

           //Texture of each particle
           explosionSystem.particleTexture = new BABYLON.Texture("images/Flare.png", scene);
  		   // Where the particles comes from
        explosionSystem.emitter = this.BoundingBox; // the starting object, the emitter
        explosionSystem.minEmitBox = new BABYLON.Vector3(0, 0, 0); // Starting all From
        explosionSystem.maxEmitBox = new BABYLON.Vector3(0, 0, 0); // To...

        // Colors of all particles (splited in 2 + specific color before dispose)
        explosionSystem.color1 = new BABYLON.Color4(0.4, 0.8, 1.0, 1.0);
        explosionSystem.color2 = new BABYLON.Color4(0.2, 0.5, 1.0, 1.0);
        explosionSystem.colorDead = new BABYLON.Color4(0, 0, 0.2, 0.0);

        // Size of each particle (random between...
        explosionSystem.minSize = 6.0;
        explosionSystem.maxSize = 7.5;

        // Life time of each particle (random between...
        explosionSystem.minLifeTime = 0.15;
        explosionSystem.maxLifeTime = 1.15;

        // Emission rate
        explosionSystem.emitRate = 50000;
        // OR
        //particleSystem.manualEmitCount = 1000;


        // Blend mode : BLENDMODE_ONEONE, or BLENDMODE_STANDARD
        explosionSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ONEONE;

        //Set the gravity of all particles (not necessary down)
        explosionSystem.gravity = new BABYLON.Vector3(0, -9.81, 0);

        //Direction of each particle after it has been emitted
        explosionSystem.direction1 = new BABYLON.Vector3(-8, 8, 8);
        explosionSystem.direction2 = new BABYLON.Vector3(8, 8, -8);

        //angular speed, in radian
        explosionSystem.minAngularSpeed = 0;
        explosionSystem.maxAngularSpeed = Math.PI;

        explosionSystem.targetStopDuration = .1;

        //speed
        explosionSystem.minEmitPower = 1;
        explosionSystem.maxEmitPower = 100;
        explosionSystem.updateSpeed = 0.005;

        //dispose
        explosionSystem.disposeOnStop = true;

        //Start the particle system
        explosionSystem.start();
		//this.BoundingBox.position.y +=-100
		DeathScreen.style.display = "block";
	    ////show you died and request reset/start over
	}
			
		}
		
		this.Damage = function(intDamage)
		{
			if(this.status == true){
				this.health -= intDamage;
				HealthGauge.style.width = ((this.health / this.maxHealth)*100) + "%"; 
			}
		 if(this.health <= 0){
			 HealthGauge.style.width =  "0%"; 
			 this.explode();
		 } 
	 
		}
		
		
		this.shoot = function(){
		  if(this.Graphic._isEnabled == true){
			 bulletsshot +=1;
			 shootaudio.volume = .1;
			 shootaudio.play();
			 
			this.bullet[bulletsshot].graphic.isVisible = true;
			this.bullet[bulletsshot].graphic.setEnabled(true);
 			this.bullet[bulletsshot].graphic.position.z = this.Graphic.position.z;
 			this.bullet[bulletsshot].graphic.position.x = this.Graphic.position.x;

			if(this.Graphic.rotation.y==Math.PI){
				this.bullet[bulletsshot].direction = 'right';
				//this.bullet.push({'graphic': basebullet, 'direction':'right', 'damage':25});
			}
			else if(this.Graphic.rotation.y==0){
				this.bullet[bulletsshot].direction = 'left';
				//this.bullet.push({'graphic': basebullet, 'direction':'left', 'damage':25});
			}
			else if(this.Graphic.rotation.y==(Math.PI/2)){
				this.bullet[bulletsshot].direction = 'up';
				//this.bullet.push({'graphic': basebullet, 'direction':'up', 'damage':25});
			}
			else{
				this.bullet[bulletsshot].direction = 'down';
				//this.bullet.push({'graphic': basebullet, 'direction':'down', 'damage':25});
			}
			if (bulletsshot >= 99){
				bulletsshot=0;
			}
		  }
		}
		
		this.update = function(){
		 if(this.health <= 0){
			 this.explode();
		 } 
		 if(this.Graphic._isEnabled == true){
			 if(this.Graphic.position.x < 700 && this.Graphic.position.x > -700){
			 	this.Graphic.position.x += movex;
				this.BoundingBox.position.x = this.Graphic.position.x;
			 }
			 else
			 {
 			 	this.Graphic.position.x += movex * -2;
				movex = 0;
 				this.BoundingBox.position.x = this.Graphic.position.x;
			 }
			 if(this.Graphic.position.z < 700 && this.Graphic.position.z > -700){
			 	this.Graphic.position.z += movez;
				this.BoundingBox.position.z = this.Graphic.position.z;
			 }
			 else
			 {
 			 	this.Graphic.position.z += movez * -2;
				movez = 0;
 				this.BoundingBox.position.z = this.Graphic.position.z;
			 }
	  	  //this.Graphic.position.z += movez;
	  	  this.Graphic.position.y += movey;

	  	  //this.BoundingBox.position.z = this.Graphic.position.z;
	      }
		    if (this.LightSpeedGauge < this.LightSpeedGaugeCapacity){
		    	lightSpeedGauge.style.width = ((this.LightSpeedGauge / this.LightSpeedGaugeCapacity)*100) + "%";
		    }
			else
			{
				lightSpeedGauge.style.width = 100 + "%";
				ResourcesText.innerHTML = (this.LightSpeedGauge - this.LightSpeedGaugeCapacity) + "/" + this.ShipCapacity;
				//this.playerStats.Resources = (this.LightSpeedGauge - this.LightSpeedGaugeCapacity);
				
			}

			var totalB = this.bullet.length;
			while(totalB--){
				if (this.bullet[totalB].direction == "right")
				{
						this.bullet[totalB].graphic.position.z += this.speed + this.bulletSpeed;
				}
				else if (this.bullet[totalB].direction == "left")
				{
					this.bullet[totalB].graphic.position.z += -(this.speed + this.bulletSpeed);
				}
				else if (this.bullet[totalB].direction == "up")
				{
					this.bullet[totalB].graphic.position.x += -(this.speed + this.bulletSpeed);
				}
				else if (this.bullet[totalB].direction == "down")
				{
					this.bullet[totalB].graphic.position.x += this.speed + this.bulletSpeed;
				}
				
			}
			
		}
	}
	/////////////////////////////////////////////////////////////////
      scene.activeCamera.attachControl(canvas);
	  ////////////////////////////////////////////////////////////////
	  

	  scene.registerBeforeRender(function() {
		  if (scene.isReady()){}
	  });


  // Once the scene is loaded, just register a render loop to render it
  engine.runRenderLoop(function () {
	  time= time+(1/BABYLON.Tools.GetFps());
	  StatusText.innerHTML = Math.round(BABYLON.Tools.GetFps()) + " FPS";
	  if(loaded==true){
		  player.update();



		  /////////check for collisions/////////////////////
	  enemiesCount = enemies.length;
	  while(enemiesCount--){
		  bulletCount = player.bullet.length;
		  	   enemies[enemiesCount].update(player.Graphic.position.x,player.Graphic.position.z);
		  while(bulletCount--){
			  if(enemies[enemiesCount].enemy.intersectsMesh(player.bullet[bulletCount].graphic,false)){
				  if(enemies[enemiesCount].enemy.isVisible==true && player.bullet[bulletCount].graphic.isVisible==true){
				  	enemies[enemiesCount].Damage(player.bullet[bulletCount].damage)
			
					player.bullet[bulletCount].graphic.isVisible = false; 
					player.bullet[bulletCount].graphic.setEnabled(false);
				
				  }
			  }
		  }
		  
		  
		  if(player.BoundingBox.intersectsMesh(enemies[enemiesCount].enemy,false)==true)
		  {
			if(enemies[enemiesCount].enemy.isVisible == true){
				 player.Damage(enemies[enemiesCount].health/2);
				 enemies[enemiesCount].Damage(player.maxHealth/2);
			}
			
		  }

	  }
	  ////////////////////complete collisions/////////////
  }
    scene.render();
  });


   document.onkeydown = handleKeyDown;
  // document.onmousedown = handleMouseDown;
  // window.addEventListener( 'mousedown', onDocumentMouseDown, false );



  function handleKeyDown(event) {
    if(event.keyCode == 68){
      if(loaded==true){
         player.Graphic.rotation.y = Math.PI; 
		 movez = player.speed; // need stat on player object
		 movex = 0;
      }
    }
    if(event.keyCode == 65){
      if(loaded==true){
         player.Graphic.rotation.y = 0; 
		 movez = -player.speed;// need stat on player object
		 movex = 0;
      }
    }
   if(event.keyCode == 87){
      if(loaded==true){
         player.Graphic.rotation.y = Math.PI/2; 
		 movex = -player.speed;// need stat on player object
		 movez = 0;
      }
    }
    if(event.keyCode == 83){
      if(loaded==true){
         player.Graphic.rotation.y = Math.PI + (Math.PI/2); 
		 movex = player.speed;// need stat on player object
		 movez = 0;
      }
  }
  if(event.keyCode == 49){
    if(loaded==true){
       	player.Graphic.position = new BABYLON.Vector3(((Math.random()*1500)-750),0,((Math.random()*1500)-750)); 
		
    }
  }
  if(event.keyCode == 50){
    if(loaded==true){
		var shieldObj = BABYLON.Mesh.CreateSphere("shield", 1,50, scene);
		var shieldmaterial = new BABYLON.StandardMaterial("shieldMaterial",scene);
		shieldmaterial.wireframe = true;
		shieldObj.material = shieldmaterial;
    }
  }
  if(event.keyCode == 51){
    if(loaded==true){
       	player.Graphic.position = new BABYLON.Vector3(((Math.random()*1500)-750),0,((Math.random()*1500)-750)); 
		
    }
  }
  if(event.keyCode == 52){
    if(loaded==true){
       	player.Graphic.position = new BABYLON.Vector3(((Math.random()*1500)-750),0,((Math.random()*1500)-750)); 
		
    }
  }
  if(event.keyCode == 53){
    if(loaded==true){
       	player.Graphic.position = new BABYLON.Vector3(((Math.random()*1500)-750),0,((Math.random()*1500)-750)); 
		
    }
  }
  
         // player.Graphic.rotation.y = Math.PI/4; //up-and-left
		 // player.Graphic.rotation.y = Math.PI + Math.PI*.25; //down-and-right
		 // player.Graphic.rotation.y = Math.PI*.75; //up-and-right
  		 // player.Graphic.rotation.y = Math.PI + (Math.PI*.75) //down and left
  
  
  if(event.keyCode == 82){

    if(player.LightSpeedGauge >= player.LightSpeedGaugeCapacity && player.health > 0){
		
		movex=0;
		movez=0;
		

  	    player.Graphic.position.y += -100;
  	    player.BoundingBox.position.y +=-100
		
        var animationBox3 = new BABYLON.Animation("tutoAnimation3", "radius", 80, BABYLON.Animation.ANIMATIONTYPE_FLOAT,
                                                                        BABYLON.Animation.ANIMATIONLOOPMODE_LOOP);
        // Animation keys
        var Camerakeys = [];
        //At the animation key 0, the value of scaling is "1"
        Camerakeys.push({
            frame: 0,
            value: camera.radius
        });

        //At the animation key 20, the value of scaling is "0.2"
        Camerakeys.push({
            frame: 50,
            value: 50
        });

        //At the animation key 100, the value of scaling is "1"
        Camerakeys.push({
            frame: 100,
            value: 25
        });

        //Pluging the sequence of keys to the animation object
        animationBox3.setKeys(Camerakeys);
    	camera.animations.push(animationBox3);
	 	player.Graphic.rotation.x = Math.PI + (Math.PI/2); 
     	player.Graphic.rotation.y = (Math.PI/2); 
		lightspeedstartaudio.play();
		scene.beginAnimation(camera, 0, 100, false, 0, function(){
   			// player.Graphic.rotation.x = Math.PI + (Math.PI/2); 
   		    // player.Graphic.rotation.y = (Math.PI/2); 
			player.status = false;
	lightspeedaudio.play();
	        var shiplightspeedMove = new BABYLON.Animation("shiplightspeedMove", "position.y", 30, BABYLON.Animation.ANIMATIONTYPE_FLOAT,
	                                                                        BABYLON.Animation.ANIMATIONLOOPMODE_LOOP);
	        // Animation keys
	        var shipkeys = [];
	        //At the animation key 0, the value of scaling is "1"
	        shipkeys.push({
	            frame: 0,
	            value: player.Graphic.position.y
	        });

	        //At the animation key 20, the value of scaling is "0.2"
	        shipkeys.push({
	            frame: 25,
	            value: player.Graphic.position.y - 1000
	        });

	        //At the animation key 100, the value of scaling is "1"
	        shipkeys.push({
	            frame: 100,
	            value: player.Graphic.position.y - 13000
	        });

	        //Pluging the sequence of keys to the animation object
	        shiplightspeedMove.setKeys(shipkeys);
	    	player.Graphic.animations.push(shiplightspeedMove);

			scene.beginAnimation(player.Graphic, 0, 100, false, 0, function(){
					levelScreen.style.display = "block";
					//levelingSystem.updateResources(123);// = 123;
					
				    var scope = angular.element(levelScreen).scope();
				    scope.$apply(function(){
				        scope.Resources = (player.LightSpeedGauge - player.LightSpeedGaugeCapacity);
				    })
					
				//scene.dispose();
				level +=1;
				
				//SceneSetup();
			});
   		   		//movey = -30;
			
				//scene.dispose();
			
		});	
    }

}
  if(event.keyCode == 32){
		player.shoot();
  }
}

       </script>
</html>